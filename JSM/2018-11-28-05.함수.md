# 05.함수


## 함수를 시작하기 전에


### 자료구조 미리 엿보기
함수의 작동 원리를 이해하려면 스택의 개념을 반드시 알아야 한다. 스택은 접시 쌓기라고 생각하면 되는데, 데이터를 저장할 때는 접시처럼 차곡차곡 쌓아 올리고, 데이터를 꺼낼때는 접시처럼 맨 위부터 차례차례 내리게 된다. 즉, 마지막에 들어온 데이터가 가장 먼저 나가게 된다. `선입후출`

### 전역 변수와 지역 변수

#### 전역변수
전역번수(global variable)는 전체 영역에서 접근할 수 있는 변수이다. 함수 안에서도 접근할 수 있어야 한다.

```
g_var = 10
def func():
    print("g_var = {}".format(g_var))

if __name__ == "__main__":
    func()
```

g_var는 전역 변수이다. 함수안에서 전역 변수에 접근했고, 실행 결과를 보면 접근이 가능하다는 것을 알 수 있다.

함수 안에서 전역 변수의 변경을 해보면

```
g_var = 10

def func():
	g_var = 20
	print("g_var = {} in function".format(g_var))
	
if __name__ == "__main__":
	func()
	print("g_var = {} in main".format(g_var))
```
실행결과

```
g_var = 20 in function
g_var = 10 in main
```
실행결과를 보면 함수안에서는 `g_var` 값이 20으로 변경되었는데 함수 바깥에서 확인해 보면 값이 바뀌지 않는다. 함수 안에서 전역 변수 `g_var` 값의 변경을 시도하기 위해 선언한 `g_var` = 20은 전역 변수를 변경하는 것이 아니라 함수 안에서 새로운 지역 변수 `g_var`를 생성한 것이기 때문이다.

#### 지역 변수
지역(local variable)는 전역 변수와 반대 개념이다. 특정 지역에서만 접근할 수 있는 변수를 말한다. 특정 지역이란 함수 내부를 의미한다. 즉 함수 안에서 선언한 변수가 지역 변수이다. 지역 변수는 함수 바깥에서는 접근할 수 없고 함수가 호출될 때 생성되었다가 호출이 끝나면 사라지게 된다.

함수 안에서는 전역 변수에 접근만 할 수 있고 변경은 할 수 없는것은 아니다. 함수 안에서 전역 변수를 변경하려면 `global`이라는 함수를 사용하면 된다.

```
g_var = 10

def func():
	global g_var
	g_var = 20
	
if __name__ == "__main__":
	print("g_var : {} before".format(g_var))
	func()
	print("g_var : {} after" .format(g_var))
```

이렇게 global을 사용하면 아래처럼 바뀌게 된다.

```
g_var : 10 before
g_var : 20 after
```
여기서는 지역 변수를 따로 생성한 것이 아니라 전역 변수 `g_var`를 변경하게 되는 것이다.

#### nonlocal키워드
함수를 정희할 때 함수 내부에서 다른 함수를 정의할 수 있다.

```
def outer():
	a = 10
	def inner():
	b = 20
```
inner() 함수에서 outer() 함수의 지역 변수인 a를 변경할 수 있는지가 문제인데 변수 a는 outer() 함수 입장에서는 지역 변수지만 inner() 함수 입장에서는 지역 변수가 아니다. inner() 함수의 지역변수는 b이다.

```
a = 1

def outer():
	b = 2
	c = 3
	print(a, b, c)
	def inner():
		d = 4
		e = 5
		print(a, b, c, d, e)
	inner()
	
if __name__ == "__main__":
	outer()
```

실행결과
```
1 2 3
1 2 3 4 5
```

inner() 함수 안에서 b와 c를 바꾸려고 시도하면 outer()함수 공간에 접근하는 것이 아니라 inner() 함수 공간 안에 b와c라는 지역 변수를 생성하게 된다. b나 c는 전역 변수가 아니니 global을 사용할 수 없다. 그렇다면 inner() 함수 안에서 b와c를 어떻게 변경할까? 정답은 nonlocal을 사용하면된다.


```
def outer():
	a = 2
	b = 3
	
	def inner():
		nonlocal a
		a = 100
	inner()
	
	print("locals in outer : a = {}, b = {}".format(a, b))
	
if __name__ == "__main__":
	outer()
```

실행결과

```
locals in outer : a = 100, b = 3
```

결과를 보게되면 outer()함수의 지역변수를 inner()함수 안에서 nonlocal을 사용해서 변경하게 된다. inner()함수 안에서 outer()함수의 지역 변수 a를 사용할 것이라고 선언했기 떄문이다.

## 인자 전달 방식에 따른 분류

함수는 인자전달 방식에 따라 크게 `값에 의한전달 (call by vallue)`과 `참조에 의한 전달 (call by reference)`로 나누어진다. 파이썬은 값에 의한 전달과 참조에 의한 전달 방식을 사용하지 않기 때문에 c++코드로 알아보아야 한다.

### 값에의한 전달(call by value)

```
코드 5-6
#include <iostream>
using namespace std;

void change_value(int x, int value)
{
	x = value;
	cout << "x : " << x << " in change_value" << endl;
}

int main(void)
{
	int x = 10;
	change_value(x, 20);
	cout << "x : " << x << " in main" << endl;
	
	return 0;
}
```
실행결과

```
x : 20 in change_value
x : 10 in main
```

`#include`나 `using` 부분은 신경쓰지 않아도 된다. 주목해야 할 곳은 `void`, `int` 부분이다. 파이썬은 변수를 선언할 때 자료형을 명시하지 않는데 c++에서는 컴파일러에 알려 줘야 하므로 반드시 명시해야한다.

위의 코드에서 change_value()함수는 인자 x와 value를 받아 x에 value를 대입한다. main() 함수에서 지역 변수 x에 10을 대입한 다음 change_value() 함수를 호출하면서 value인자로 20을 전달했기 때문에 x의 값이 20으로 바뀔것 같지만 실행 결과를 보면 다른 값이 출력된다.

함수 안에서는 값이 변경 되었지만 함수를 호출한 쪽에서는 값이 변경되지 않았다. 지역 변수 x가 변경되지 않은 이유는 함수에 x가 전달될 때 값에 의한 전달 방식으로 전달 되었기 때문이다. 

함수가 호출될 때 메모리에는 '스택 프레임'이 생기게 된다. 스택 프레임은 함수의 메모리 공간 즉, 지역 변수가 존재하는 영역이다. 

```
코드 5-7
#include <iostream>
using namespace std;

int test(int a, int b);

int main(void)
{
	int a = 10, b = 5;
	int res = test(a, b):
	cout << "result of test : " << res << endl;
	return 0;
}


int test(int a, int b)
{
	int c = a + b;
	int d = a - b;
	return c + d;
}
```

위의 코드에서 주의깊게 봐야할 것은 test()함수의 정의와 main()함수에서 test()함수를 호출하는 부분이다. test()함수는 인자로 a와b를 받고, 지역 변수로 c와 d를 선언한다. 함수를 호출하면 아래와 같은 스택 프레임이 메모리에 생긴다.

![스택 프레임표1](./img/stack1.png)

위의 그림은 test()함수가 호춮될 때 생기는 스택 프레임이다. 스택 프레임에는 함수를 호출한 다음 복귀할 주소 값 등 지역 변수 이외의 정보도 담고 있다. main()함수도 함수이므로 스택 프레임을 갖는다 main() 함수의 스택 프레임의 모습은 아래와 같다.

![스택 프레임2](./img/stack2.png)

```
main()함수의 b를 먼저 꺼내기 때문에 
test()함수에서 b가 아래에 깔리고 a가
그 위로 올라가는 것 이다.)
```

main()함수가 먼저 실행 되므로 스택 프레임이 먼저 쌓이고 main()함수 안에서 호출한 test()함수의 스택 프레임은 그 위에 쌓이게 된다. test()함수가 모두 실행되면 test() 함수의 스택 프레임이 먼저 사라지고 이후에 프로그램이 종료되면 main()함수의 스택 프레임이 사라지게 된다.

위의 표를 보게 되면 main()함수의 스택 프레임 공간에도 a와 b가 있고 test()함수의 스택 프레임 공간에도 a와 b가 있다. 두 공간은 서로 독립된 공간이다. 

`int res = test(a, b);`코드를 보면 인자를 전달 할 때 main()함수 스텍프레임의 지역변수인 a와 b를 전달한 것 같지만, 실제로는 test()함수 스택 프레임의 지역 변수 a와 b에 값만 '복사'한 것이다. 이처럼 인자를 전달할 때 값을 복사해 전달하는 경우를 '값에 의한 전달`call by value`'라고 한다. 말 그대로 값을 복사할 뿐이다.

이제 코드 5-6의`change_value(x, 20);`에서 change_value() 함수를 호출할 떄의 스택 프레임을 보고 main()함수의 지역 변수 x가 변경되지 않는 이유를 보도록 하자. 아래의 그림은 코드 5-6의 `x = value;`가 실행되기 직전에 본 스택 프레임이다.
![스택 프레임3](./img/stack3.png)
change_value()함수 스택 프레임의 x와 main()함수 스택 프레임의 x는 서로 다른 메모리 공간에 존재하는 서로 다른 변수이다. 값만 10으로 같을 뿐이다. 아래의 그림은 `x = value;`가 실행되고 난 후의 스택 프레임 모습이다.
![스택 프레임4](./img/stack4.png)
x에 value값을 대입했으므로 x값은 20이다.
여기서 중요한 점은 서로 다른 변수이기 때문에  main()함수의 지역 변수 x값은 변하지 않는다는 것이다. change_value() 함수는 change_value 스택 프레임의 지역 변수 x 값인 20을 출력하고, 실행이 끝나면 스택 프레임은 사라지게 된다. 아래의 그림은 change value() 함수의 호출을 완료한 후의 스택 프레임 모습이다.
![스택 프레임5](./img/stack5.png)
이 상태에서 x 값을 출력하면 10이 출력된다. main()함수안의 지역 변수 x가 change_value() 함수 호출 후에도 값이 변경되지 않았는지 알았다. 인자를 값에 의한 전달 방식으로 전달했기 때문이다. 

함수 호출로 x값을 바꾸려면 참조에 의한 전달 방식으로 인자를 전달하면 된다.

### 참조에 의한 전달
참조에 의한 전달(call by reference)방식은 인자를 전달할 때 값을 전달하는게 아니라 참조를 전달한다.

```
코드5-8
#include <iostream>
using namespace std;

void change_value(int *x, int value)
{
	*x = value;
	cout << "x : " << *x << " in change_value" << endl;
}

int main(void)
{
	int x = 10;
	change_value(&x, 20);
	cout << "x : " << x << " in main " << endl;
	return 0;
}
```

실행결과
```
x : 20 in change_value
x : 20 in main
```

코드 5-8과 5-6을 비교해보면 함수 인자 목록에 int `x가 int *x로 바뀌었고, x = value;가 *x = value;`로 바뀌었다.

또한 change_value(x, 20)이 change_value(&x, 20)으로 바뀌었다. *와 & 연산자가 각각 무슨일을 하는지 알아보기 전에 실행 결가를 확인 해보면 이전에는 main()함수 안의 지역 변수 x 값이 바뀌지 않았는데 이번에는 바뀐 것을 알 수 있다.
`int*은 int형` 포인트를 의미한다. 아래의 그림은 change_value()함수를 호출했을 때 `*x = value`가 실행되기 직전에 본 스택 프레임 모습이다.
![스택 프레임6](./img/stack6.png)
change_value(&x, 20);에서 &x로 인자를 전달한다. 이는 main()함수 스택 프레임의 변수 x가 위치한 메모리 공간의 첫 번째 바이트 주소 값을 전달한다는 의미이다. 즉, 값 10을 전달하는 게 아니라 데이터 10을 저장하고 있는 4바이트 공간 중 첫 번째 바이트의 주소 값을 전달한다. `void change_value(int *x, int value)`의 인자 목록에서`int*x`는 포인터 변수를 의미한다. 포인터 변수도 다른 변수처럼 데이터를 저장한다. 단지 그 데이터가 메모리 주소일 뿐이다. change_value()함수 스택 프레임의 포인터 변수 x는 &x를 통해 change_value(&x, 20);에서 전달된 main()함수 스택 프레임 안의 지역 변수 x의 주소 값을 저장합니다. 포인터 변수가 주소 값을 저장한다는 것은 위의 그림에서 change_value 스택 프레임 안에 있는 int형 포인터 x가 화살표를 따라 main() 함수의 지역 변수 x를 가리키는 것과 같은 의미이다. 이렇게 인자로 변수의 참조를 전달하는 방식을 참조에 의한 전달이라고한다(call by reference).
![스택 프레임7](./img/stack7.png)
