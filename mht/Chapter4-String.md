## 문자와 문자열

**참조 문서**

[문자 인코딩(위키백과)](https://ko.wikipedia.org/wiki/%EB%AC%B8%EC%9E%90_%EC%9D%B8%EC%BD%94%EB%94%A9)

### *<u>알아두면 쓸모있는 제곱의 값</u>

> **1부터 2의 12제곱까지**


| 계산값 | 결과값 |
|------|------|
| 2^0  | 1    |
| 2^1  | 2    |
| 2^2  | 4    |
| 2^3  | 8    |
| 2^4  | 16   |
| 2^5  | 32   |
| 2^6  | 64   |
| 2^7  | 128  |
| 2^8  | 256  |
| 2^9  | 512  |
| 2^10 | 1024 |
| 2^11 | 2048 |
| 2^12 | 4096 |


> **2의제곱을 비트로 환산**

| 계산값 | 결과값                                              |
|--------|-----------------------------------------------------|
| 2^1    | 2                                                   |
| 2^2    | 4                                                   |
| 2^4    | 16                                                  |
| 2^8    | 256                                                 |
| 2^16   | 65,536                                              |
| 2^32   | 4,294,967,296                                       |
| 2^64   | 18,446,744,073,709,551,616                          |
| 2^128  | 340,282,366,920,938,463,463,374,607,431,768,211,456 |




## <u>2진법과 모스부호</u>

> 컴퓨터는 문자를 모른다. 숫자도 **0과 1** 단 2개의 2진법 구조에 의하여 연산 처리가 가능하다.

즉, 컴퓨터끼리는 `0과 1` 단 2개의 숫자만으로 모든 표현이 가능하다. 원래 컴퓨터의 용도는 단순한 숫자 계산용으로 사용되었었다.(현재는 사람의 일자리까지 위협하는 큰 존재가 되었지만 말이다.)

그런데 0과 1로 컴퓨터가 연산을 하는 것처럼 사람도 비슷한 방식을 사용했었다.

> **바로 모스부호이다.**

<U>**컴퓨터가 2진법의 구조를 가지고 있다면 사람은 예전부터 모스 부호를 사용했다.**</U>

전건을 길게 또는 짧게 눌러 받은 그 신호를 해석하고 문자로 받아적는 행위가 컴퓨터가 사용하는 `인코딩`의 개념이다.


## <u>컴퓨터는 항상 인코딩을 하고 있다</u>

1. 브라우저에서 '안녕하세요' 라고 입력한다.

2. 해당 브라우저는 설치되어있는 부호화된 문자 집합(CCS)에 의하여 '안녕하세요' 라는 값을 2진법화 시켜서 저장한다.

3. 이 내용을 메일로 보내고, 2진법으로 컴퓨터는 저장을 하고 있다.

4. 상대방이 메일을 읽는 순간 부호화된 문자 집합(CSS)을 다시 사람이 읽을 수 있도록 인코딩하여 보여준다.

즉, 눈에 보이지 않지만 무수한 과정들이 반복되어 일어나는 것을 확인할 수 있다.

```
사람 <-> 제공하는 문자 코드표 <-> 컴퓨터
```

## <u>아스키코드의 탄생</u>

> 표준화된 코드가 없이 데이터 송수신이 이루어진다면 어떻게 될까?

```
철수의 컴퓨터는 A = 0001 0010

영희의 컴퓨터는 A = 0100 1100
```

추측1) 매핑된 위치 자체가 다르기 때문에 상대방의 컴퓨터에는 다른 글자가 나오던지, 깨지게 될 것이다.

추측2) 만약 어떻게 잘 매핑을 시켰다고 치더라도 철수가 보낸 데이터를 영희가 읽기 위해서는 영희의 컴퓨터에서 별도의 인코딩 작업이 필요하게 된다.

코드화된 문자 집합이 통일되었다면 그냥 2진 데이터를 영희에게 보내고 코드포인트에 맞는 문자를 매핑시켜서 영희에게 보여주면 끝나는 일을 말이다.

물론 이는 내 지식과 문서를 찾아보는데 한계점도 분명히 있을 것이기에 개인적인 견해도 담겨있다.

여하튼 코드화된 문자 집합(CSS, Code Character Set), 바로 아스키코드를 만들어 각각의 문자에 매핑을 시킨 코드표를 만들고 사용하게 되었다.

![아스키코드표](./image/ASCII.png)


## <u>아스키코드?</u>

미국정보교환표준부호(ASCII, American Standard Code for Information Interchange)

**비트 일곱 개로 문자를 표현**

> 7비트!?

비트 하나당 0 또는 1을 가지고 있다. 그리고 1비트는 한개의 값을 2비트는 2개의 값을 가지고 있다.

즉, 7비트는 아래처럼 총 7개의 자리에 위치한다.

```
000 0000
000 0001
..
..
111 1110
111 1111
```

즉, 2**7(2^7) = 총 128개의 조합이며, 128개의 문자를 매핑할 수 있다는 뜻이다.

```python
ch = 'A'

bch = ch.encode()

bch
>> b`A`

bch[0]
>> 65

```

위의 코드를 보면 Char 'A'를 변수에 담아서 인코딩한 후에 불러온 값을 확인하는 단순한 코드이다. bch를 출력하게 되면 binary 코드로 A 자체가 나오지만, 인덱싱으로 [0] 을 사용하여 찾게되면 아스키코드 표에서의 10진법으로 아스키코드에서 128개 중 몇번째에 위치해있는지 확인할 수 있다.

당연한 얘기지만 대문자와 소문자는 아스키코드에서 코드 포인트가 다르다.

```python
ch = 'a'

bch = ch.encode()

bch
>> b'a

bch[0]
>> 97

```

대문자 A는 아스키코드상에서 65번째

소문자 a는 아스키코드상에서 97번째

그리고 몇번째임을 확인할 수 있는 순서는 10진법으로 표현했다.

## <u>아스키코드는 7비트이다.</u>

일반적으로 기수법에 의거하여 2의n승으로 표현을 한다. 그리고 1바이트는 8비트이기 때문에 왠만하면 아스키코드도 8비트로 만드는 것이 더 효율적이라 생각할 수 있다. 그러나 아스키코드는 7비트로 표현을 하게 되는데 이는 이유가 있다.

첫번째, 컴퓨터를 나타내는데 쓰는 자료형은 바이트 수에 따라 다양한데, int형이 가장 많이 쓰이며 이 int형은 32비트(4바이트)이다. 그런데 아스키코드는 총 128개의 코드표인데 33비트가 필요하지 않다. 이는 오히려 리소스 낭비이다.

`32비트(=4바이트=2의4승=256개)`

즉, 128개(7비트)면 표현할 수 있는 것을 굳이 2배의 메모리를 사용하며 표현할 필요는 없기 때문에 새로운 자료형 char 형이라는 새로운 정수 자료형을 만들어서 사용한다.

두번째, 이건 어디까지나 내 추측도 담겨있는 얘기이기는 하지만 아스키코드는 미국에서 자신들이 필요한 영어와 특수문자가 담긴 표준 코드표를 만들고 아스키코드로 정의했을 가능성도 있다고 본다.

'어디보자..알파벳 A부터 Z, a부터 z, 특수문자를 포함하고 보니 대충 128개가 되는구나. 다른 언어들을 더 넣자니 여러가지 규칙들을 새로 정의해야 할 것도 같고, 영어로 사용해도 하려고 하는 사람들은 다 하지 않을까?' 라는 생각으로 만들지 않았을까도 그저 추측해본다.



## <u>유니코드의 탄생</u>

> 아스키코드 안에 꾸역꾸역 집어넣은 각 나라의 문자들을 넉넉한 유니코드 공간으로 재구성

컴퓨터가 전세계적으로 보급됨에 따라서 영어로만 의사소통에는 한계가 있었다. 그리고 실제로 다른 나라에서는 아스키코드 안에 자국의 언어를 담아 하나의 코드표를 만들었었다. 한 국가 안에서 사용하는 것은 괜찮지만 가장 큰 문제는 다른 나라로 메일을 보냈을 때이다.

예를 들어 프랑스에서 한국으로 메일을 보냈을 때 아스키코드 안에 각 나라의 문자를 담았을텐데, 이는 곧 문자가 매핑되어도 알 수 없는 문자가 매핑되기 때문에 글자가 깨지는 현상이 발생하였다. 이는 8비트 체계로 128개의 코드표에서 256개로 늘렸지만 유럽이나 영어권은 어떻게든 조합이 된다고 쳐도 아시아쪽에서는 무조건 부족할 터였다. 한국, 중국, 일본만 하더라도 고유의 언어들이고 무수히 많은 조합이 이루어지기 때문에 문제는 불보듯 뻔한 상황이었다.

유니코드를 만든 사람은 이러한 문제들을 예상하여 현재 모든 문자들이 담길 수 있는 16비트(65,536개) 체계의 유니코드가 완성된 것이다.
