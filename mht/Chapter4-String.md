## 문자와 문자열

거듭 얘기하지만 컴퓨터는 문자를 모르고, 숫자도 0과 1 단 2개의 숫자만을 알고 있다.

그래서 2진법으로 각 문자를 매핑시켜서 코드표를 만들어두어 이를 사용한다.

그리고 정리를 하기 전에 2의n승에 대해서도 미리 알아두면 이해가 쉬울 것 같다.

**1부터 2의 12제곱까지**


| 계산  | 결과값 |
|------|------|
| 2^0  | 1    |
| 2^1  | 2    |
| 2^2  | 4    |
| 2^3  | 8    |
| 2^4  | 16   |
| 2^5  | 32   |
| 2^6  | 64   |
| 2^7  | 128  |
| 2^8  | 256  |
| 2^9  | 512  |
| 2^10 | 1024 |
| 2^11 | 2048 |
| 2^12 | 4096 |


**2의제곱을 비트로 환산**

| 계산값 | 결과값                                              |
|--------|-----------------------------------------------------|
| 2^1    | 2                                                   |
| 2^2    | 4                                                   |
| 2^4    | 16                                                  |
| 2^8    | 256                                                 |
| 2^16   | 65,536                                              |
| 2^32   | 4,294,967,296                                       |
| 2^64   | 18,446,744,073,709,551,616                          |
| 2^128  | 340,282,366,920,938,463,463,374,607,431,768,211,456 |


### 아스키코드

미국정보교환표준부호(ASCII, American Standard Code for Information Interchange)

**비트 일곱 개로 문자를 표현**

즉, 2**7(2의7승) = 128개의 문자를 만들 수 있다는 뜻이다.

```python
ch = 'A'

bch = ch.encode()

bch
>> b`A`

bch[0]
>> 65

```

위의 코드를 보면 Char 'A'를 변수에 담아서 인코딩한 후에 불러온 값을 확인하는 단순한 코드이다. bch를 출력하게 되면 binary 코드로 A 자체가 나오지만, 인덱싱으로 [0] 을 사용하여 찾게되면 아스키코드 표에서의 10진법으로 아스키코드에서 128개 중 몇번째에 위치해있는지 확인할 수 있다.

당연한 얘기지만 대문자와 소문자는 아스키코드에서 코드 포인트가 다르다.

```python
ch = 'a'

bch = ch.encode()

bch
>> b'a

bch[0]
>> 97

```

대문자 A는 아스키코드상에서 65번째

소문자 a는 아스키코드상에서 97번째

그리고 몇번째임을 확인할 수 있는 순서는 10진법으로 표현했다.

### 아스키코드는 7비트이다.

일반적으로 기수법에 의거하여 2의n승으로 표현을 한다. 그리고 1바이트는 8비트이기 때문에 왠만하면 아스키코드도 8비트로 만드는 것이 더 효율적이라 생각할 수 있다. 그러나 아스키코드는 7비트로 표현을 하게 되는데 이는 이유가 있다.

첫번째, 컴퓨터를 나타내는데 쓰는 자료형은 바이트 수에 따라 다양한데, int형이 가장 많이 쓰이며 이 int형은 32비트(4바이트)이다. 그런데 아스키코드는 총 128개의 코드표인데 33비트가 필요하지 않다. 이는 오히려 리소스 낭비이다.

`32비트(=4바이트=2의4승=256개)`

즉, 128개(7비트)면 표현할 수 있는 것을 굳이 2배의 메모리를 사용하며 표현할 필요는 없기 때문에 새로운 자료형 char 형이라는 새로운 정수 자료형을 만들어서 사용한다.

두번째, 이건 어디까지나 내 추측도 담겨있는 얘기이기는 하지만 아스키코드는 미국에서 자신들이 필요한 영어와 특수문자가 담긴 표준 코드표를 만들고 아스키코드로 정의했을 가능성도 있다고 본다.

'어디보자..알파벳 A부터 Z, a부터 z, 특수문자를 포함하고 보니 대충 128개가 되는구나. 다른 언어들을 더 넣자니 여러가지 규칙들을 새로 정의해야 할 것도 같고, 영어로 사용해도 하려고 하는 사람들은 다 하지 않을까?' 라는 생각으로 만들지 않았을까도 그저 추측해본다.

### 유니코드의 탄생

컴퓨터가 전세계적으로 보급됨에 따라서 영어만이 아니다. 그리고 실제로 다른 나라에서는 아스키코드 안에 자국의 언어를 담아 하나의 코드표를 만들었었다. 한 국가 안에서 사용하는 것은 괜찮지만 가장 큰 문제는 다른 나라로 메일을 보냈을 때이다.

예를 들어 프랑스에서 한국으로 메일을 보냈을 때 각자 아스키코드 안에 각 나라의 문자를 담았을텐데, 이는 곧 자동으로 인코딩이 되지 않기 때문에 글자가 깨지는 현상이 발생하였다. 이는 8비트 체계로 128개의 코드표에서 256개로 늘렸지만 각 국가마다 선호(?)하는 다른 나라의 언어들이 있기 때문이 이 역시도 부족할 터였다.

개선단계를 거치며 현재 모든 문자들이 담길 수 있는 16비트(65,536개) 체계의 유니코드가 완성된 것이다.

