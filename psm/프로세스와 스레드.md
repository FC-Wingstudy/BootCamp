## 프로세스와 스레드

### 프로세스

+ 프로세스는 더블클릭으로 프로그램을 실행한 상태
	+ 하드디스크에서 메인 메모리로 코드와 데이터를 가져와 현재 실행되고 있는상태
	+ 프로세스는 동시에 여러 개가 존재할 수 있음
+ 예) 메모장을 두개 실행하면 독립적인 프로세스 두개가 생성된다
	+ `독립적`이라는 의미는 프로세스가 사용하는 메모리 공간도 서로 다르다는 의미


### 프로세스 상태
+ 생성(created)
	+ 프로그램을 더블클릭했을 때 프로세스가 생성되면서 실행 가능 상태
	+ 곧바로 실행 상태가 되는 것이 아니라, 우선 실행 가능 상태가 되어 실행 중인 프로세스와 우선순위를 비교 한다음 우선순위가 높으면 실행하고 아니면 실행 가능 상태에서 순서를 기다린다.
	
+ 실행가능(Waiting)
	+ 실행 가능 상태의 프로세스는 언제든지 실행될 준비가 되어 있다.
	+ 운영체제는 인터럽트가 발생했을때 실행 가능 상태의 프로세스 중 다음으로 CPU를 할당받아 실행될 프로세스를 결정한 후 실행 중인 프로세스와 교체
	+ 이때 다음으로 실행될 프로세스에 CPU를 할당하는 것을 `디스패치(dispatch)`라고 하고, 실행중이던 프로세스에서 CPU를 해제하는 것을 `프리엠션(preemption)`이라 한다.

+ 실행(Runnig)
	+ 프로세스가 운영체제로부터 CPU를 할당받아 실행되고 있는 상태

+ 보류(Blocked)
	+ 프로세스가 입출력 작업을 하면 CPU를 해체하고 보류 상태로 변경
	+ 이때 실행 가능 상태의 프로세스 중 하나가 CPU를 할당받음
	+ 보류 상태에 들어간 프로세스는 입출력 작업이 모두 끝나면 실행 가능 상태로 변경
	+ 입출력 작업이 완료된 다음 바로 실행 상태로 변경되는 것이 아니라, 실행 가능 상태가 되어 실행되기를 기다린다는 점
	+ 또한 실행 대기 상태(Waiting)와 보류(Blocked)상태를 구분 할 수 있어야한다
	+ 실행 대기 상태는 언제든지 다시 실행될 수 있는 상태를 말하지만 보류 상태는 입출력 작업이 끝나기 전에는 실행이 불가능한 상태

+ 소멸(Terminated)
	+ 프로세스 실행이 완료되어 메인 메모리에서 사라짐


### 스케줄링

+ 스케줄링(scheduling)
	+ 운영체제가 여러 프로세스의 CPU 할당 순서를 결정하는 것

+ 스케줄링은 CPU를 언제 할당하는지에 따라 `선점형 스케줄링(preemptive scheduling)`과 `비선점형 스케줄링(non-preemptive scheduling)`으로 나뉨
+  선점형 스케줄링(preemptive scheduling)
	+ 어떤 프로세스가 실행 중에 있어도 스케줄러가 강제로 실행을 중지하고 다른 프로세스에 CPU를 할당할 수있다

+ 비선점형 스케줄링(non-preemptive scheduling)
	+ 실행 중인 프로세스가 종료되거나 입출력 작업에 들어가거나 명시적으로 CPU를 반환하기 전까지 계속해서 실행

> 우선순위가 높은 프로세스가 생성되어도 실행 중인 프로세스가 자발적으로 CPU를 양보하기 전까지는 실행될수 없다

### `윈도를 포함한 최근 운영체제는 멀티태스킁을 위해 선점형 스케줄링을 한다`

1. 우선순위(Priority)
	+ 알고리즘 프로세스에 우선순위를 매겨 우선순위가 높은 프로세스를 먼저 실행
	+ 어떤 프로세스가 CPU를 할당받고 실행되는 도중에 우선순위가 높은 프로세스가 생성되면 스케줄러는 실행 중인 프로세스를 실행 가능 상태로 만들고 우선순위가 높은 프로세스를 실행
	+ 계속해서 우선순위가 높은 프로세스가 생성되면 우선순위가 낮은 프로세스는 계속 CPU를 할당받지 못하는 현상이 발생하는데 이를 `기아 상태(starvation)`라 한다
	+ 이를 해경하기 위해 우선순위가 낮은 프로세스가 일정 시간 CPU를 할당받지 못하면 우선순위를 높여 실행될 수 있도록 만드는데 이러한 방법을 에이징(aging)이라 한다

2. 라운드 로빈(Round-Robin)
	+ 알고리즘 실행 가능 상태에 있는 프로세스들을 순서대로 가져와 일정 시간 동안 CPU를 할당하는 방식
	+ 모든 프로세스에 같은 시간이 부여
	+ 이때 프로세스에 부여된 일정 시간을 `타임 슬라이스(time slice)` 혹은 `퀸텀(quantum)`이라 함
	+ 라운드 로빈을 이용하면 모든 프로세스가 동시에 실행되는 것 처럼보임
	+ 대표적으로 선점형 스케줄링
	+ 스케줄링에서 가장 중요한 것은 타임 슬라이스를 얼마로 정하는냐

3. FCFS(First Come First Seved)
	+ 실행 가능 상태에 먼저 들어온 프로세스를 먼저 실행하는 방법
	+ 비선점 스케줄링
	
4. SJF(Shortest Job First)
	+ 평균 대기 시간을 최소화하기 위해 CPU 할당 시간이 가장 짧은 프로세스를 먼저 실행
	+ CPU의 실제 할당 시간을 알 수 없으므로 예측에 의존해야 하는 단점


### 컨텍스트 스위칭
+ 프로세스가 실행되려면 다양한 CPU 레지스터 값과 프로세스 상태 정보등이 필요
+ 그러므로 프로세스가 실행 상태에서 실행 가능 상태로 변경될 때 이러한 정보를 메모리 어딘가에 저장해야 한다
+ 프로세스 제어 블록(Process Control Block, PCB)
	+ 프로세스의 CPU 상태와 프로세스의 상태를 저장해 둔 메모리 블록

+ 컨텍스트 스위칭(context switching)
	+ 스케줄러가 실행 중인 프로세스에서 CPU를 해제하고 실행 가능 상태의 프로세스에 CPU를 할당할때 실행 중인 프로세으의 CPU 상태 정보를 그 프로세스의 PCB 에 저장하고 곧 실행될 프로세스의 PCB에서 이전 CPU 상태 정보를 CPU로 가져오는 것

+ CPU 상태를 컨텍스트라고 부르는데 말 그대로 현재 CPU의 레지스터 값들을 `전환(switching)`하는 것

### 스레드

+ 스레드(thread)
	+ 프로세스 안의 실행 흐름의 단위로 스케줄러에 의해 CPU를 할당받을 수 있는 인스터럭션의 나열
	+ 프로세스는 하나 이상의 스레드로 구성
+ 프로세스가 PCB를 갖는 것처럼 스레드는 `스레드 제어블록(Thread Control block, TCB)`을 갖는다
	+ TCB에는 스레드 ID, 각종 레지스터 정보, 스레드 상태 정보, 스레드가 속해 있는 프로세스의 PCB 주소 등이 저장되어 있다
	+ TCB 정보는 PCB와 매우 유사
	+ CPU의 레지스터 정보와 스레드의 상태 정보는 정확하게 프로세스와 같음
	+ 프로세스 상태나 컨텍스트 스위칭이 스레드에도 똑같이 적용
+ 프로세스와 스레드 모두 인스트럭션의 나여링고 유사한 정보가 든 메모리 블록을 갖음
+ 프로세스가 단일 스레드로 작동하면 프로세스와 스레드는 차이가 없음
+ 프로세스와 스레드의 차이점을 알려면 멀티프로세스와 멀티스레드를 비교 하기
+ 멀티프로세스(multi-process)
	+ 프로세스 여러 개를 동시에 실행하는 것
	+ 코드, 데이터, 힙, 스택 모든 프로세스가 서로 다른 메모리 공간을 가짐
	+ 데이터를 공유하려면 특별한 기법을 사용해야함
+ 멀티스레드(multi-thread)
	+ 스레드를 여러 개 만들어 동시에 실행하는 것
	+ 여러 스레드가 스택만 서로 다른 공간을 갖고 코드, 데이터, 힙은 공유함

+ 스레드는 각자 독립적인 스택 세그먼트를 갖지만, 고드, 데이터, 힙은 다른 스레드와 공유함
+ 데이터 세그먼트나 힙 세그먼트에 공유 데이터를 두면 모든 스레드가 이용할수 있다
+ 동시성 프로그래밍(concurrency)
	+ 동시에 여러 실행 흐름이 필요한 프로그래밍을 `동시성 프로그래밍`이라하고 이를 구현할때 `멀티스레딩`을 이용

