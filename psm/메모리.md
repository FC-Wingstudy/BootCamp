## 메모리  (`책 참조해서 보기`)

### 메모리 저장방식
+ 빅 엔디언(big-endian) 1,2,3,4 순서대로 저장 되는것
+ 리틀 엔디언(little-endian) 4,3,2,1 순서 반대로 저장 되는 것

### 메모리 계층

+ 메모리 계층 구조(memory hierarchy)
	+ 레지스터 -> 캐시 -> 메모리 -> 하드디스크


### 지역성과 캐시 히트

+ 캐시란?
	+ CPU가 데이터를 요청하면 메인 메모리에서 해당 데이터만 가져오는 것이 아니라, 그 데이터와 함께 인접 데이터로 이루어진 메모리 블록을 `캐시 행(cache line)`이라고 하는데 크기는 `64 ~ 128`바이트 정도이다.
+ CPU가 다시 다른 데이터를 요청하면 메인 메모리에서 가져오지 않고 우선 캐시에 요청한 데이터가 있는지 확인
	+ 캐시 히트(cache hit)
		+ 요청한 데이터가 캐시에 있다면 캐시히트라 부른다
	+ 캐시 미스(cache miss)
		+ 캐시에 없어서 메인 메모리에서 가져와야 한다면 캐시미스라 한다
	
+ 캐시에서 데이터를 읽어올 때는 3사이클이 걸림
+ 메인 메모리에서 데이터를 가져오는 것보다 훨씬 빠름
+ CPU가 데이터를 요청했을 때 캐시 히트가 계속 일어나면 날수록 시스템 성능이 좋아짐

+ 지역성(locality)
	+ 시간적 지역성, 공간적 지역성
	+ 지역성의 원리(principle of locality)
		+ 데이터 접근이 같은 메모리 공간이나 인접한 메모리 공간에서 자주 일어난다는 의미
	+ 시간적 지역성(temporal locality)
		+ 특정 데이터에 한 번 접근했을 때 곧 다시 그 데이터에 접근할 가능성이 높다
	+ 공간적 지역성(spatial locality)
		+ 이번에 접근할 데이터는 이전에 접근했던 데이터의 근처에 있을 확률이 높다

+ 캐시 프렌들리 코드(cache friendly code)		
	+ 캐시 히트가 잘 일어나도록 지역성을 고려해 작성한 코드



### 가상 주소 공간

1. 코드 세그먼트(code segment, 텍스트 세크먼트라고도 함)
	+ 프로그램의 인스트럭션이 저장되는 공간
	+ 예) 작성한 함수나 클래스 정의 코드는 인스트럭션으러 변환되어 하드디스크에 저장되어 있다가 프로세스가 실행되면 가상 주소 공간의 코드 세그먼트네 올라간다. 함수를 호출하면 프로그램 카운터가 함수의 인스트럭션이 있는 메모리 주소를 가리킴으로써 함수를 실행함
2. 데이터 세그먼트(data segment)
	+ 전역변수가 저장되는 공간
	+ 프로세스가 실행될 때 데이터 세그먼트에 올라가고 프로세스가 종료될 때 소멸(프로그램이 실행되는 동안 계속 있으며 프로그래머가 생성 시기나 소멸 시기를 결정 못함)

3. 스택 세그먼트(stack segment)
	+ 지역 변수가 저장되는 공간
	+ 함수를 호출했을 때 그 스택 프레임이 스택 세그먼트에 생성된다는 의미
	+ 런타임 동안 늘어났다 줄어들기를 반복하지만 최대로 늘어날수 있는크기가 정해져있다
	+ 최대 크기는 프로그램을 작성할 때 프로그래머가 정할 수 있는데 정하지 않으면 기본값으로 1MB가 할당된다.
	+ 스택 프레임이 쌓이다 최대 크기를 넘기면 `스택 오버플로(Stack over flow)`오류가 발생
	
4. 힙 세그먼트(heap segment)
	+ 프로그래머가 자유롭게 메모리를 할당하고 해체할 수 있는 공간
	+ 함수 호출이 끝나면 스택프레임이 사라지면서 해제되는 지역변수와 달리 힙 세그먼트에 할당한 메모리는 해제하지 않는 한 메모리 공간에 계속 남아 있다
	+ 힙 세그먼트에 메모리를 할당한 다음 해제하지 않아 메모리가 계속 남아 있는 상활을 `메모리 누수(memort leak)`라고 한다
	+ 메모리 단편화(memory fragmentation)
		+ 총합은 충분하지만 관련 데이터가 한데 모이지 못하고 서로 멀리 떨어져 저장될수 있다
		
		
### 스택 프레임

> 스택 포인터(stack pointer), 프레임 포인터(frame pointer)

#### 스택 프레임 할당

+ 호출 규약(calling convention)
	+ 함수가 호출될 때 스택에 인자를 할당하거나 해제하는 주체가 함수를 호출한 쪽(caller)인지, 호출된 함수(callee)인지 정해 놓은것



+ esp(extended stack pointer)
	+ 스택 세그먼트의 맨위를 가리키는 스택 포인터 레지스터
+ mov(MOVE)
	+ 복사하는 명령어
+ push
	+ 데이터를 스택에 쌓는 명령어
+ eax 범용레지스터
	+ main 스택프레임의 n 값을 범용 레지스터 eax로 복사한 다음 다시 스택에 쌓는다.
	+ main 스택 프레임에서 adder 스택 프레임으로 바로 복사하는 것이 아니라 레지스터를 거쳐 스택에 할당한다.
+ ebp(extended base pointer)
	+ 프레임 포인터 레지스터
	+ 스택 프레임에 있는 지역 변수에 접근할 때도 프레임 포인터를 이용해 접근
+ pop
	+ 스택의 맨 위에 있는 데이터를 꺼내 옮기는 명령어
+ ret
	+ 스택에 저장해 둔 프로그램 카운터 값을 복원하는 명령어


### 가상 메모리와 페이징

1. 가상메모리(virtual memory)
	+ 메인 메모리를 확장하기 위해 페이지 파일로 불리는 하드디스크의 일정 부분을 메인 메모리처럼 사용하는 것
	+ 메인 메모리와 하드디시크의 페이지 파일을 합쳐 `물리 메모리(physical memory)`라한다
	+ 가상 메모리 관리 기법은 가상 주소 공간을 쪼개는 기준에 따라 `세그먼테이션(segmentation)기법`, ` 페이징(paging)기법`으로 나뉜다.

2. MMU(Memory Management Unit)
	+ MMU는 논리 주소를 물리 주소로 런타임에 대응시키는 하드웨어로 과거에는 따로 존재했지만 지금은 CPU 내부에 있다. 
	+ 프로세스에 주어지는 메모리 공간을 `가상 주소 공간(virtual address space)`이라 한다
	+ 가상 주소 공간의 메모리 주소를 `논리 주소(logical address)`라 한다
	+ 메인 메모리의 메모리 주소를 `물리 주소(physical address)`라 한다
	
3. 페이징
	+ 가상 주소 공간과 메인 메모리를 일정한 크기로 나눔
	+ 가상 주소 공간을 일정한 크기로 쪼개는데 이때 쪼개진 한 부분을 페이지(page)라고 부른다
		+ 페이지 크기는 시스템마다 다른데 보통 1 ~ 8KB, 32비트 시스템에서는 일반적으로 4096바이트 즉, 4KB 이다.
		+ 페이지 개수 = 가상 주소 공간 크기 / 페이지 크기
	+ 페이지 순서를 나타내는 비트를 페이지 넘버라 하는데 VPN(virtual page number)이라 고도 부름
	+ 페이지 않에서 특정 바이트를 가리키는 비트를 `오프셋(offset)`이라 부름

4. 페이지 프레임
	+ 메인 메모리도 가상 주소 공간과 같은 크기로 쪼갬. 쪼개진 부분 하나를 `페이지 프레임(page frame)`이라고 부른다.
	+ 메인 메모리의 프레임이 가상 주소 공간의 페이지와 크기가 같은 이유는 실제로 존재하지 않는 페이지를 실제로 존재하는 프레임에 할당하기 위해서
	+ 프레임 순서를 나타내는 비트를 `프레임 넘버(frame number)`라고 하고 또는 `PPN(Physical Page Number)`라고도 부름

5. 페이지 테이블
	+ 어떤 프로세스의 페이지 넘버(VPN), 상응하는 프레임 넘버(PPN), 상태(control bits)등을 저장하는 테이블
	+ 페이지 테이블은 메인 메모리에 저장
	+ CPU에는 페이지 테이블의 시작 주소(Page Table Base Address, PTBA)를 가리키는 `PTBR(Page Table Base Register)`라는 레지스터가 있다.
	
6. 요구 페이징
	+ 가상 메모리는 요구 페이징(demand paging)으로 구현
	+ 요구 페이징이란?
		+ 프로세스를 실행할 때 모든 페이지를 프레임에 매핑하는 것이 아니라, 필요한 페이지만 메인 메모리에 올려 실행하는 것을 말함
	+ 프리페어링(preparing)
		+ 프로세스가 처음 실행될 때 운영체제는 페이지 테이블을 메인 메모리에 만들고 실행에 필요할 것 같은 페이지만 먼저 프레임에 매핑한다.

7. 페이지 폴트(page fault)
	+ CPU가 요청한 페이지가 메인 메모리에 없을 때 발생
	+ 유효 비트를 확인하면 알 수 있는데 유효 비트가 0이면 메인 메모리에 존재하지 않는다.
	+ 페이지 폴트가 발생하면 해당 페이지를 하드디스크에서 가져와 빈프레임에 할당하면 된다.

8. 변환 색인 버퍼(Translation Lookaside Buffer, TLB)
	+ 주소 변환 속도를 높이기 위한 일종의 캐시
	+ 변환 색인 버퍼에는 최근에 사용된 페이지 테이블의 일부가 저장되어 있음
	+ MMU가 페이지 테이블에서 프레임 넘버를 읽어 와야 할 때 먼저 TLB에 해당 항목(페이지 넘버와 그에 매핑되는 프레임 넘버 즉, 페이지 테이블의 일부)이 있는지 확인
	+ TLB에 해당 항목이 있는 경우 `TLB히트`라 한다
		+ 메인 메모리에 있는 페이지 테이블에 직접 접근하지 않아도 되므로 굉장히 빠름!!!
	+ TLB에 해당 항목이 없는 경우 `TLB미스`라 한다
		+ MMU는 메인 메모리에 있는 페이지 테이블에 직접 접근해 해당 항목을 TLB에 상입한 뒤에야 TLB에 프레임 넘버를 가져올 수 있다. 그만큼 느림(TLB에도 지역성 원리가 적용되는데 TLB히트 확률이 99% 달함)
	